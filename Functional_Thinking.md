# 함수형 사고

## Chapter1. 왜

언어는 당신 발밑에서 점점 함수형으로 바뀔것이다.

사용하는 언어에 나중에 함수형 패러다임이 도입되었을 때, 잘 사용하려면 지금 배워야한다.

### 1.1 패러다임의 전환

컴퓨터 과학은 단속적으로 발전한다. 수십 년 전의 훌륭한 아이디어가 어느 날 갑자기 주류에 포함되곤 하는 식이다.

명령형 프로그래밍을 하다 보면 효율을 높이기 위해 여러 작업을 한 루프에 넣음으로써, 작업들을 복잡하게 하는 경우가 종종 있다.

함수형 프로그래밍에서는 map()이나 filter()와 같은 고계함수를 통해 추상화의 단계를 높여서 문제를 더욱 명료하게 볼 수 있다.

### 1.2 언어 트렌드에 발맞추기

주요 언어들이 변화하는 것을 보면, 모두 다 함수형 기능을 더하고 있다.

### 1.3 언어/런타임에 제어를 양도하기

왜 모든 플랫폼들이 함수형 프로그래밍을 채택하는가?

과거의 사례에서 왜 함수형 프로그래밍을 채택하는지 찾아볼 수 있는데, 자바가 가비지 컬렉션을 채택한 것과 비슷한 맥락이다. 까다로운 저수준의 문제는 더이상 생각하고 싶지 않다.

개발자들은 지루한 일들은 언어나 런타임에 점점 맡기게 된다. 그런일에 무관심해졌기 때문에 좀 더 중요한 문제들에 집중할 수 있다.

### 1.4 간결함

객체지향 프로그래밍은 움직이는 부부을 캡슐화하여 코드 이해를 돕고, 함수형 프로그래밍은 움직이는 부분을 최소화하여 코드 이해를 돕는다.

OOP의 캡슐화, 스코핑, 가시성등의 매커니즘은 **상태** 변화를 누가 볼 수 있는지에 대한 세밀한 제어를 위해 존재한다. 상태에 스레드까지 곁들이면 골칫거리는 더욱 커진다.

이런 부분이 움직이느 부분이다.

함수형 언어는 불변 상태를 제어하는 매컨니즘을 구축하기 보다, 그런 움직이는 부분을 아예 제거하는데 주력한다. 언어가 오류가 발생하기 쉬운 기능을 적게 노출하면 오류를 만들 가능성이 줄어든다는 이론에 따른다.

함수형 개발자는 적은 수의 자료구조와 그것들을 잘 이해하기 위한 최적화된 방법을 만들기를 선호한다.

객체지향형 개발자는 항상 새로운 자료구조와 그것에 부착된 메서드를 만든다.

## 2. 전환

함수형 코드를 작성하기 위해서는, 문제에 접근하는 방식의 전환이 필요하다.

### 2.1 일반적인 예제

함수형 프로그래밍은, 복잡한 최적화는 런타임에게 맡기고 개발자가 좀 더 추상화된 수준에서 코드를 작성할 수 있게 함으로써, 알고리즘 측면에서 가비지 컬렉션과 동일한 역할을 수행할 것이다.

### 2.1.1 명령형 처리

for 루프가 명령형 프로그래밍의 훌륭한 예이다. 초기 상태를 설정하고, 되풀이할 때마다 일련의 명령을 시행한다.

명령형 프로그래밍은 개발자로 하여금 루프 내에서 연산하기를 권장한다.

### 2.1.2 함수형 처리

함수형 프로그래밍은 프로그램을 수학 공식을 모델링하는 표현과 변형으로 기술하며, 불변 상태를 지양한다.

개발자는 고계함수에 매개변수로 주어지는 함수를 이용하여 저수준의 작업을 커스터마이즈 할 수 있다.

함수형 사고로의 전환은, 어떤 경우에 세부적인 구현에 뛰어들지 않고 이런 고수준 추상 개념을 적용할지를 배우는 것이다.

고수준의 추상 사고로 얻는 이점

- 문제의 공통점을 고려하여 다른 방식으로 분류하기를 권장한다.
- 런터임이 최적화를 잘할 수 있도록 해준다.
- 개발자가 엔진 세부사항에 깊이 파묻힐 경우 불가능한 해답을 가능하게 한다.

### 2.2 사례연구 : 자연수의 분류

문법적인 편리함은 중요하다. 한 언어로 아이디어를 표현하는 방식이 곧 문법이기 때문이다.

스몰토크에서 자바로의 전환을 처음에는 단순한 문법적인 불편으로 보았지만, 종국에는 스몰토크의 세상에서 가능했던 사고방식을 저해하는 일로 생각하게 되었다고 말했다. 여기저기 끼어드는 문법적인 장애 때문에, 추상적 개념이 사고과정과 불필요하게 마찰을 빚게된다.

### 2.3 공통된 빌딩 블록

유용한 작업들은 함수형 언어 및 프레임워크에 어디에나 존재한다.

### 2.3.1 필터

목록에 할 수 있는 흔한 작업은 필터를 거는것이다.

사용자가 정한 조건으로 목록에 있는 요소들을 필터하여 더 작은 목록을 만드는 작업이다.

```java
public static InStream factorsOf(int number){
	return range(1, number+1)
						.filter(potential -> num % potential == 0);
}
```

1~대상숫자까지의 목록을 만들고 filter() 메서드를 적용하여 약수가 아닌 숫자들을 제거한다.

### 2.3.2 맵

맵 연산은 각 컬렉션의 각 요소에 같은 함수를 적용하여 새로운 컬렉션으로 만든다.

### 2.3.3 폴드/리듀스

foldLeft나 reduce는 캐시모피즘이라는 목록 조작 개념의 특별한 변형이다.

누산기로 값을 모으는 개념.

## Chapter3. 양도하라

이 장에서는 함수형 언어를 사용하는 개발자가 언어나 런타임에 제어를 양도하는 다섯 가지 방식을 살펴보겠다. 이를 통해 개발자는 좀 더 중요한 문제를 풀 시간을 얻을 수 있을 것이다.

### 3.1 반복 처리에서 고계함수로

map과 같은 함수를 사용하여 제어를 포기하는 방법이 있다.

고계함수 내에서 어떤 연산을 할것인지를 표현하기만 하면, 언어가 그것을 능률적으로 처리할 것이다. 게다가 par라는 변형자를 덧붙이기만 하면 분산처리까지 해준다.

→ 스레드를 관리하는 골치 아픈 일들을 도우미에게 떠넘기면 개발자는 밑에 깔린 배관 작업에 신경을 덜 써도 된다.

하지만 저수준 추상 단계에서 코드가 어떻게 동작하는지 이해는 하고 있어야한다.

예) Java Stream에 함축된 의미를 알아야지만, 즉 그 안에서 동작하는 포크/조인 라이브러리의 세부사항을 이해해야 좋은 성능을 낼 수 있다.

추상화는 낮은 단계의 지저분한 것들을 감춰주지만, 종종 중요한 사실도 감출 수 있음을 명심해야한다.

### 3.2 클로저

클로저 : 내부에서 참조되는 모든 인수에 대한 묵시적 바인딩을 지닌 함수. 다시 말하면, 이 함수는 자신이 참조하는 것들의 문맥(context)를 포함한다.

```groovy
package com.nealford.ft.simple_closure

class Employee {
	def name, salary
}

def paidMore(amount){
	return {Employee e -> e.salary > amount}

isHighPaid = paidMore(100000)
```

paidMore이라는 함수의 리턴값이 “클로저”라는 코드블록이다.

리턴값은 다음과 같은 역할을 하는 함수다.

- input : Employee라는 class
- output : amount보다 많이 받는가?

이 코드블록에 100,000을 매개변수로 주고 isHighPaid라는 인수에 할당한다.

이렇게 하면, 100,000라는 값은 이 코드블록에 영원히 **바인딩된다.** 

클로저가 생성될 때에, 이 코드 블록의 스코프에 포함된 인수들을 둘러싼 상자가 같이 만들어진다. 그래서 이름을 클로저라 지어졌다.

클로저는 함수형 언어나 프레임워크에서 코드 블록을 다양한 상황에서 실행하게 해주는 매커니즘으로 많이 쓰인다.

클로저란 단어의 어원이 encoding context이란 점에서 이 작업의 내용을 추측할 수 있다.

자바 8 이전이나, 함수는 있지만 클로저는 지원하지 않는 다른 언어를 사용해서 이오하 같은 기능을 가장 가깝게 구현할 수 있는 방법은 다음과 같다.

```java
package com.nealford.ft;

import java.util.List;
import java.util.ArrayList;

class Counter{
	public int varField;

	Counter(int var){
		varField = var;
	}

	public static Counter makeCounter(){
		return new Counter(0);
	}

	public int execute(){
		varField++;
	}
}
```

어떤 경우에나 개발자가 내부상태(varField)를 관리해야한다.

→ 함수형 사고 : 런타임에 내부 상태의 관리를 맡긴다. → 클로저

클로저는 지연실행의 좋은 예다. 클로저 블록에 코드를 바인딩함으로써 그 블록의 실행을 나중으로 연기할 수 있다.

명령형 언어는 상태로 프로그래밍 모델을 만든다.(매개변수 주고받기)

클로저는 코드와 문맥을 한 구조로 캡슐화해서 행위의 모델을 만들 수 있게 해준다.

**상태 대신 문맥을 잡으라.**

### 3.3 커링과 부분적용

커링이나 부분적용은 함수너 메서드의 인수의 개수를 조작할 수 있게 해준다.

### 3.3.1 정의와 차이점

process(x,y,z)

→ 커링후 : process(x)(y)(z)

→ 부분적용 후 : process(y,z)

커링 : 다인수 함수를 일인수 함수의 체인으로 바꿔주는 방법이다.이것은 변형 과정이지, 변형된 함수를 실행하는 것을 지칭하는 것은 아니다. 함수의 호출자가 몇개의 인수를 고정할지를 결정하여 적은수의 인수를 가지는 함수를 유도해낸다.

부분적용 : 주어진 다인수 함수를 생략될 인수의 값을 미리 정해서 더 적은 수의 인수를 받는 하나의 함수로 변형하는 방법이다. 이 방법은 이름이 의미하듯이 몇몇 인수의 값을 미리 적용하고 나머지 인수만 받는 함수를 리턴한다.

### 보편적인 용례

정의도 까다롭고 구현방법도 다양하지만, 커링과 부분적용은 실제로 프로그래밍에서 큰 자리를 차지한다.

**함수 팩토리**

객체지향언어에서 팩토리 함수를 구현할 상황에 사용하면 좋다.

**템플릿 메서드 패턴**

갱 오브 포의 디자인 패턴 중에 템플릿 메서드 패턴이 있다. 이 패턴의 목적은 구현의 유연성을 보장하기 위해서 내부의 추상 메서드를 사용하는 겉껍질을 정의하는데 있다.

부분 적용과 커링이 이 문제를 해결하는데 사용된다.

**묵시적 값**

비슷한 인수 값들로 여러 함수를 연속적으로 불러 올 때에는 커링을 사용하여 묵시적 인수값을 제공할 수 있다.

### 3.3.2 재귀

재귀란 자신을 재참조하여 같은 프로세스를 반복하는것을 말한다.

→ 런타임에게 세구 구현사항을 양도하는 예가 되고, 그래서 함수형 프로그래밍과 깊은 관계가 있다.

재귀 : 같은 메서드를 반복적으로 호출해서 컬렉션을 단계마다 줄여가면서 반복처리하는것을 말한다.

명령형 언어에서 바라보는 리스트 : 색인된 컬렉션

함수형 언어에서 바라보는 리스트 : 첫요소(머리)와 나머지(꼬리)의 조합.

→ 재귀는 상태관리를 런타임에 양도할 수 있게 해준다.

움직이는 부분의 관리를 런타임에 양도하는 것이다.

함수형 프로그래밍언어는 스택의 증가 없이 재귀를 구현하여 안정성을 가져왔다.

### 3.4 스트림과 작업 재정렬

```java
public String cleanName(List<String> names){
	if(names == null) return "";
	return names
					.stream()
					.map(e -> capitalize(e))
					.filter(n -> n.length() > 1)
					.collect(Collectors.joining(","));
```

map()작업이 filter()작업보다 먼저 실행된다.

당연히 filter()가 먼저와야하는게 아닌가?

하지만, 함수형 언어에서는 Stream이란 추상개념이 정의되어있다. Stream은 여러모로 Collection과 유사하지만, 바탕 값이 없다(backing value). 대신 원천에서 목적지까지 값이 흐르게 한다.

map()과 filter()는 게으른 함수이다. 이들은 실행을 가능하면 미룬다.

런타임은 필터를 맵 작업 전에 실행하여 게으른 작업을 효율적으로 재정렬할 수 있다.

filter()같은 함수에 람다 블록에 부수 효과가 없어야한다. 아니면 예측할 수 없는 결과가 초래된다.

런타임에 최적화를 맡기는 것이 양도의 중요한 예다. 세부사항 말고, 구현에 집중할 수 있게 된다.

# Chapter4. 열심히보다는 현명하게

함수형 언어에서 보편적인 두가지 기능에 대해 알아본다. **메모이제이션**과 **게으름**이다.

## 4.1 메모이제이션

연속해서 사용되는 연산 값을 함수 레벨에서 캐시하는 것을 지칭하는 것.

오늘날 메모이제이션은 함수형 프로그래밍 언어에서 흔히 내장된 기능이거나 쉽게 구현할 수 있는 기능이다.

: 더 좋은 성능을 위해 메모리를 더 많이 사용한다.

캐싱이 제대로 작동하려면 함수가 순수해야한다.

순수함수란, 부수효과가 없는 함수를 말한다.

- 불변 클래스 필드를 참고하지 않고
- 리턴 값 외에는 아무 값도 쓰지 않아야 하며,
- 주어진 매개변수에만 의존해야한다.

주어진 매개변수에 대해 항상 같은 을 리턴하는 함수에 한해서만 캐시된 값을 재사용할 수 있다.

### 4.1.1 캐싱

이 절에서는 두가지의 캐싱 용례를 알아본다.

- 클래스 내부에서의 사용
- 클래스 외부에서의 사용

더불어, 캐싱을 구현하는 두가지 방법도 알아보자.

- 수작업으로 만든 상태
- 메모이제이션

**메서드 레벨에서의 캐싱**

```java
if (Classifier.isPerfect(n)) print "!"
else if (Classifier.isAbundant(n)) print "+"
else if (Clssifier.isDeficient(n)) print "-"
```

이것은 클래스 내부 캐싱의 예이다. 이 경우 sumOfFactors()가 각각의 수에 대해 여러번 호출된다.

→ 비효율적!

**합산결과를 캐시하기**

이미 수행된 결과를 재사용하는 것이 코드를 효율적으로 만드는 한 방법이다.

매개변수의 합을 구하는 것이 어렵기 때문에 각 수마다 한 번만 계산하고자 한다. 이를 위해서는 각 계산결과를 저장할 캐시를 만들어햐한다.

```java
package com.nealford.ft.memoization

class ClassifierCachedSum {
	private sumCache [:]

	def sumOfFactors(number){
		if (!sumCache.containKey(number)){
			sumCache[number] = factorsOf(number).sum()
		}
		return sumCache[number]
	}
```

트레이드 오프 : 클래스는 순수한 정적 메서드만 가질 수 없다. 내부 캐시가 상태를 표시하기 때문에 이 캐시를 사용하는 모든 메서드를 인스턴스 메서드로 만들어야한다.

캐싱이 성능을 향상시켰지만 코드를 복잡하게 하고 유지 보수를 어렵게 하는 대가를 치뤄야한다.

모든 데이터를 캐싱하기에는 메모리가 부족하다.

개발자는 정확함과 함께 실행 조건도 신경써야한다.

실행조건은 움직이는 부분의 적절한 예이다. 

수많은 언어가 메모이제이션과 같은 메커니즘을 사용하여 이러한 제약을 극복해냈다.

### 4.1.2 메모이제이션의 첨가

함수형 프로그래밍은 런타임에 재사용 가능한 매커니즘을 만들어서 움직이는 부분을 최소화하는데 주력한다.

메모이제이션은 프로그래밍 언어에 내장되어 반복되는 함수의 리턴값을 자동으로 캐싱해주는 기능이다.

그루비에서 함수를 메모아이즈 하기 위해서는 함수를 클로저로 정의하고 리턴값이 캐시되는 함수를 리턴하는 memoize()메서드를 실행해야한다.

메모아이즈된 함수는

- 부수효과가 없어야하고
- 외부 정보에 절대로 의존하지 말아야한다.

## 4.2 게으름

표현의 평가를 최대한 늦추는 기법.

필요에 따라 전달해주는 기법.

- 시간이 많이 걸리는 연산을 필요할때까지 미룰 수 있게 된다.
- 요청이 계속되는 한 요소를 계속 전달하는 무한 컬렉션을 만들 수 있다.
- 맵이나 필터같은 함수형 개념을 게으르게 사용하면 효율이 높은 코드를 만들 수 있다.

### 4.2.1 자바의 게으른 반복자

게으름을 만드려면 자료구조부터 그 개념을 지원해야한다.

자바는 게으른 컬렉션을 네이티브로 지원하지 않지만, Iterator를 사용하면 흉내를 낼 수는 있다.

전민수 :  이 구현은 파이썬의 제너레이터와 비슷함.

### 4.2.2 토털리 레이지 자연수 분류기

토털리 레이지는 장황하게나마 자바 구문을 함수형 메커니즘 쪽으로 바꿔주는 자바 프레임워크이다.

### 4.2.3 그루비의 게으른 목록

함수형 언어의 대표적인 기능은 내용물을 필요할 때만 만들어내는 게으른 목록이다.

게으른 목록은 초기화하기 어려운 리소스를 반드시 필요할 때까지 지연할 수 있게 해준다.

또한 게으른 목록을 쓰면 끝이 없는 무한수열을 만들 수 있다.

‘목록'을 ‘번호가 붙은 슬롯들'로 추상화 한다면 무한수열은 이해하기가 어렵다.

목록을 첫요소와 나머지 요소들로 추상화 한다면, 그 내부 구조보다는 요소들로서 생각할 수 있게 된다.

### 4.2.4 게으른 목록 만들기

```groovy
package com.nealford.ft.lazy_primes

class PLazyList{
	private Closure list

	private PLazyList(list){
		this.list = list
	}
	
	static PLazyList nil(){
		new PLazyList({-> []})
	}

	PLazyList cons(head){
		new PLazyList({-> [head, list]})
	}
	
	def head(){
		def lst = list.call()
		lst ? lst[0] : null
	}

	def tail() {
		def lst = list.call()
		lst ? new PLazyList(lst.tail()[0]) : nil()
	}

	boolean isEmpty() {
		list.call() == []
	}

	def fold(n, acc, f) {
		n == 0 || isEmpty() ? acc : tail().fold(n-1, f.call(acc, head()), f)
	}

	def foldAll(acc, f) {
		isEmpty() ? acc : tail().foldAll(f.call(acc, head()), f)
	}

	def take(n){
		fold(n, []) {acc, item -> acc << item}
	}

	def takeAll(){
		foldAll([]) {acc, item->acc<<item	}
	}

	def toList(){
		takeAll()
	}
}
```

head() : 목록의 첫요소를 리턴한다

 tail() : 첫요소를 제외한 모든 요소를 포함하는 부분목록을 리턴한다

fold(), foldAll() : 폴드 연산을 수행한다.

### 4.2.5 게으름의 이점

1. 무한수열을 만들 수 있다.
2. 저장 시 크기가 줄어든다.
3. 런타임이 좀 더 효율적인 코드를 만들 수 있다.

### 4.2.6 게으른 필드 초기화

게으른 초기화 시 적시 재활용을 사용하는 가장 메모리 사용이 최적화 된 버전

@Lazy : 게으른 요소

soft=true : 가비지 컬렉션

# 5. 진화하라

함수형 언어에서의 코드 재사용은 객체지향 언어와는 접근 방법이 다르다.

객체지향언어는 수많은 자료구조와 거기에 딸린 수많은 연산을 포함한다.

함수형 언어에는 적은 수의 자료구조와 많은 연산들이 있기 마련이다.

객체지향 언어는 클래스에 종속된 메서드를 만드는 것을 권장하며 반복되는 패턴을 재사용하려한다.

함수형 언어는 자료구조에 대해 공통된 변형 연산을 적용하고, 특정 경우에 맞춰서 주어진 함수를 사용하여 작업을 커스터마이즈함으로써 재사용을 장려한다.

이 장에서는 언어들이 소프트웨어에서 반복되는 문제의 해결 방법을 어떻게 진화시켜왔는지를 살펴보자.

특화된 자료구조에 대한 함수형 프로그래밍의 자세를 알아보고, 언어와 해법의 다양성, 디스패치 방법들, 연산자 오버로딩, 함수형 자료구조에 대해 살펴보겠다.

## 5.1 적은 수의 자료구조, 많은 연산자

100개의 함수를 하나의 자료구조에 적용하는 것이 10개의 함수를 10개의 자료구조에 적용하는것보다 낫다.

객체지향적인 명령형 프로그래밍 언어에서 재사용의 단위는 클래스와 그것들이 주고받는 메시지들이다.

OOP세상에서는 특정한 메서드가 장착된 특정한 자료구조를 개발자가 만들기를 권장한다.

함수형 언어에서는 몇몇 주요 자료구조와 거기에 따른 최적화된 연산을 선호한다.

함수형 오류 처리 → Optional(Either)

## 6. 전진하라

함수형 프로그래밍에서는 전통적인 디자인 패턴들이 다음과 같은 세가지로 나타난다.

- 패턴이 언어에 흡수된다.
- 패턴 해법이 함수형 패러다임에도 존재하지만, 구체적인 구현 방식은 다르다.
- 해법이 다른 언어나 패러다임에 없는 기능으로 구현된다.

**함수 수준의 재사용**

함수현 프로그래밍은 구조물들 간에 잘 알려진 관계를 만들기보다는, 큰 단위의 재사용 매커니즘을 추출하려한다.

고계함수가 있기 때문에 명령 패턴이나 템플릿 패턴 같은 고전적인 패턴에서 자주 보이는 보일러플레이트 코드가 필요 없어진다.

함수형은 상속보다는 구성.

구성을 더 좋아한다.

구성이 신이다.